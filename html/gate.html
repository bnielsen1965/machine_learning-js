<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Neuron Gate</title>
  <style>
    table {
      border-collapse: collapse;
      border: 1px solid black;
    }
    tr:nth-child(even) {
      background-color: #eee;
    }
    th {
      border: 1px solid black;
      padding: 4px;
      background-color: #aaa;
    }
    td {
      border: 1px solid black;
      padding: 4px;
      text-align: center;
    }
    td input {
      width: 2em;
    }
  </style>
</head>
<body>
  <h1>Neuron Gate</h1>
  <svg width="650" height="350" style="background-color: #aaa;">

    <circle
       style="fill:#69f9ff;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       id="path288"
       cx="323.79459"
       cy="223.56174"
       r="65.544632" />
    <text
       xml:space="preserve"
       style="font-size:33.5447px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="323.81137"
       y="235.5372"
       id="text1010"><tspan
         sodipodi:role="line"
         id="tspan1008"
         style="fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="323.81137"
         y="235.5372">Σ</tspan></text>
    <circle
       style="fill:#69f9ff;fill-opacity:1;stroke:#000000;stroke-width:1.48574;stroke-linecap:round;stroke-dasharray:none"
       id="circle1172"
       cx="323.79459"
       cy="48.47139"
       r="33.774952" />
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="323.51157"
       y="54.897339"
       id="text2632"><tspan
         sodipodi:role="line"
         id="tspanbias"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="323.51157"
         y="54.897339">β</tspan></text>
    <circle
       style="fill:#69f9ff;fill-opacity:1;stroke:#000000;stroke-width:1.48574;stroke-linecap:round;stroke-dasharray:none"
       id="circle10032"
       cx="162.4182"
       cy="168.70464"
       r="33.774952" />
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="163.85223"
       y="175.34648"
       id="text10036"><tspan
         sodipodi:role="line"
         id="tspanweight1"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="163.85223"
         y="175.34648">ω1</tspan></text>
    <circle
       style="fill:#69f9ff;fill-opacity:1;stroke:#000000;stroke-width:1.48574;stroke-linecap:round;stroke-dasharray:none"
       id="circle10038"
       cx="162.4182"
       cy="276.76236"
       r="33.774952" />
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="162.29555"
       y="283.49857"
       id="text10042"><tspan
         sodipodi:role="line"
         id="tspanweight2"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="162.29555"
         y="283.49857">ω2</tspan></text>
    <circle
       style="fill:#69f9ff;fill-opacity:1;stroke:#000000;stroke-width:1.48574;stroke-linecap:round;stroke-dasharray:none"
       id="circle10044"
       cx="488.8743"
       cy="223.56174"
       r="33.774952" />
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="487.58914"
       y="229.28845"
       id="text10048"><tspan
         sodipodi:role="line"
         id="tspan10046"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="487.58914"
         y="229.28845">f(x)</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="47.783344"
       y="175.44083"
       id="text10052"><tspan
         sodipodi:role="line"
         id="tspaninput1"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="47.783344"
         y="175.44083">x1</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="46.226662"
       y="283.5929"
       id="text10056"><tspan
         sodipodi:role="line"
         id="tspaninput2"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="46.226662"
         y="283.5929">x2</tspan></text>
    <text
       xml:space="preserve"
       style="font-size:18.8689px;text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:1.5;stroke-linecap:round"
       x="598.69067"
       y="226.35434"
       id="text10060"><tspan
         sodipodi:role="line"
         id="tspanoutput"
         style="font-size:18.8689px;fill:#000000;fill-opacity:1;stroke-width:1.48574"
         x="598.69067"
         y="226.35434">y</tspan></text>
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="M 64.714047,168.70463 H 116.45998"
       id="path10107"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="M 64.714047,276.76235 H 116.45998"
       id="path10449"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="m 203.21055,276.76235 50.22396,-19.78524"
       id="path10451"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="m 203.21055,167.62851 50.22396,19.78524"
       id="path10453"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="m 393.45304,223.56173 h 51.74594"
       id="path10455"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="m 525.86185,223.56173 h 51.74594"
       id="path10457"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.486;stroke-linecap:butt;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#TriangleStart)"
       d="m 323.79458,94.19689 v 51.74594"
       id="path10459"
       inkscape:connector-type="polyline"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
  </svg>

  <hr>
  
  Select a logic gate type:<br>
  <button type="button" onclick="setDataSet('AND');">AND</button> <button type="button" onclick="setDataSet('NAND');">NAND</button> <button type="button" onclick="setDataSet('OR');">OR</button> <button type="button" onclick="setDataSet('NOR');">NOR</button><br>
  <br>
  <table>
    <caption>Gate Type: <span id="gatetype">...</span></caption>
    <tr><th>x1</th><th>x2</th><th>y</th><th></th><th>Actual</th></tr>
    <tr><td><input id="x1-1"></td><td><input id="x2-1"></td><td><input id="y-1"></td><td><button type="button" onclick="test(1);">Test</button></td><td id="r-1"></td></tr>
    <tr><td><input id="x1-2"></td><td><input id="x2-2"></td><td><input id="y-2"></td><td><button type="button" onclick="test(2);">Test</button></td><td id="r-2"></td></tr>
    <tr><td><input id="x1-3"></td><td><input id="x2-3"></td><td><input id="y-3"></td><td><button type="button" onclick="test(3);">Test</button></td><td id="r-3"></td></tr>
    <tr><td><input id="x1-4"></td><td><input id="x2-4"></td><td><input id="y-4"></td><td><button type="button" onclick="test(4);">Test</button></td><td id="r-4"></td></tr>
  </table>
  <br>
  <button type="button" onclick="train();">train</button><br>
  <span id="trainmessage"></span>



<script>
  // define logic gate data sets and training settings

// definition of 2 input AND gate
const DataAND = [
  { inputs: [0, 0], result: 0 },
  { inputs: [0, 1], result: 0 },
  { inputs: [1, 0], result: 0 },
  { inputs: [1, 1], result: 1 }
];

// definition of 2 input NAND gate
const DataNAND = [
  { inputs: [0, 0], result: 1 },
  { inputs: [0, 1], result: 1 },
  { inputs: [1, 0], result: 1 },
  { inputs: [1, 1], result: 0 }
];

// definition of 2 input OR gate
const DataOR = [
  { inputs: [0, 0], result: 0 },
  { inputs: [0, 1], result: 1 },
  { inputs: [1, 0], result: 1 },
  { inputs: [1, 1], result: 1 }
];

// definition of 2 input NOR gate
const DataNOR = [
  { inputs: [0, 0], result: 1 },
  { inputs: [0, 1], result: 0 },
  { inputs: [1, 0], result: 0 },
  { inputs: [1, 1], result: 0 }
];

// array of defined training sets for logic gates
const TrainingSets = [
  { name: "AND", data: DataAND },
  { name: "NAND", data: DataNAND },
  { name: "OR", data: DataOR },
  { name: "NOR", data: DataNOR }
];

// Target acceptable error rate for neuron model
const ErrorTarget = 0.0001;

// Maximum number of training runs to try before failure
const MaxRuns = 1400000;

// learning rate applied to input weight to adjust for error
const LearnRate = 0.1;

// bias and error rate tweaks applied during training
const Tweak = 0.001

</script>



<script>
// initialize after page is loaded
window.addEventListener("load", () => init());

// declare global variables
// let data;
let gateNeuron;

// application initialization method
function init () {
  setDataSet("AND");
}

// set the current data set
function setDataSet(gateType) {
  // create an untrained random neuron to use as a boolean logic gate
  gateNeuron = new BooleanNeuron([Math.random(), Math.random()], Math.random());
  for (const dataSet of TrainingSets) {
    if (dataSet.name == gateType) {
      document.getElementById("gatetype").innerHTML = gateType;
      // data = dataSet.data;
      dataSet.data.forEach((row, i) => {
        document.getElementById(`x1-${i + 1}`).value = row.inputs[0];
        document.getElementById(`x2-${i + 1}`).value = row.inputs[1];
        document.getElementById(`y-${i + 1}`).value = row.result;
        document.getElementById(`r-${i + 1}`).innerHTML = "";
      });
      return;
    }
  }
}

// test model against data row
function test (rowNumber) {
  let x1 = document.getElementById(`x1-${rowNumber}`).value;
  let x2 = document.getElementById(`x2-${rowNumber}`).value;
  let y = document.getElementById(`y-${rowNumber}`).value;
  let a = gateNeuron.model([x1, x2]);
  displayNeuronValues(gateNeuron, x1, x2, a);
  document.getElementById(`r-${rowNumber}`).innerHTML = a;
  document.getElementById(`r-${rowNumber}`).style.color = a != y ? "red" : "green";
}

// disable/enable all buttons
function disableButtons (disable) {
  let buttons = document.getElementsByTagName("button");
  for (const button of buttons) {
    button.disabled = disable;
  }
}

// train the neuron
function train () {
  document.getElementById("trainmessage").innerHTML = "";
  disableButtons(true);
  console.log(`Training...`);

  // build data set from inputs
  let data = [];
  for (let i = 1; i < 5; i++) {
    data.push({
      inputs: [
        Number(document.getElementById(`x1-${i}`).value),
        Number(document.getElementById(`x2-${i}`).value)
      ],
      result: Number(document.getElementById(`y-${i}`).value)
    });
  }

  // show random neuron results
  console.log("Untrained neuron output:");
  BooleanTraining.showOutput(gateNeuron, data);
  BooleanTraining.showModel(gateNeuron);

  // create a duplicate training neuron with sigmoid activation so we get linear error results
  let train_neuron = new BooleanNeuron(gateNeuron.weights, gateNeuron.bias, BooleanNeuron.sigmoid);

  console.log("\nTrain neuron...");
  console.log(`Initial neuron error ${BooleanTraining.calculateError(train_neuron, data)}.`);
  let result = BooleanTraining.train(train_neuron, data, LearnRate, Tweak, MaxRuns, ErrorTarget);
  console.log(`Trained neuron error ${result.error} in ${result.count} training runs.\n`);

  // copy trained model values to the untrained neuron
  gateNeuron.weights = train_neuron.weights.slice();
  gateNeuron.bias = train_neuron.bias;

  let message = "";
  if (!BooleanTraining.test(gateNeuron, data)) message = "Training failed, neuron does not produce expected output.";
  else message = "Training successful.";
  document.getElementById("trainmessage").innerHTML = message;
  console.log("Trained neuron output...");
  BooleanTraining.showOutput(gateNeuron, data);
  BooleanTraining.showModel(gateNeuron);
  console.log("\n\n");
  disableButtons(false);
}

// update svg with neuron model values
function displayNeuronValues (neuron, x1, x2, y) {
  setElementText("tspanweight1", Math.round(neuron.weights[0] * 100) / 100);
  setElementText("tspanweight2", Math.round(neuron.weights[1] * 100) / 100);
  setElementText("tspanbias", Math.round(neuron.bias * 100) / 100);
  setElementText("tspaninput1", x1 === undefined ? "x1" : x1);
  setElementText("tspaninput2", x2 === undefined ? "x2" : x2);
  setElementText("tspanoutput", y === undefined ? "y" : y);
}


function setElementText (id, val) {
  let element = document.getElementById(id);
  if (!element) return;
  element.innerHTML = val;
}


</script>




<script>
// neuron class files copied into static web page


/*
* The Neuron class provides the foundation of a machine learning neuron with a constructor
* to define the model input weights, bias, and the output activation function and the model 
* function to process inputs with the defined model and provide the output result.
*/

class Neuron {
  /*
  * Represents a single neuron
  * @constructor
  * @param {Number[]} inputWeights An array of initial input weights.
  * @param {Number} bias An initial bias value.
  * @param {function} activation The activation function to apply before output.
  */
  constructor (inputWeights, bias, activation) {
    if (!inputWeights || !inputWeights.length) throw new Error("New neuron requires input weights.");
    if (!Array.isArray(inputWeights)) throw new Error("Input weights must be an array of weights.");
    this.activation = activation;
    this.bias = bias || 0;
    this.weights = inputWeights.slice();
  }

  /*
  * Calculates neuron output from given inputs.
  * @param {Number[]} inputs An array of neuron input values.
  */
  model (inputs) {
    if (inputs.length != this.weights.length) throw new Error("Mismatch between number of data inputs and number of neuron inputs.");
    let result = this.bias;
    for (let i = 0; i < inputs.length; i++) result += inputs[i] * this.weights[i];
    return this.activation ? this.activation(result) : result;
  }
}




/*
* The BooleanNeuron class extends the Neuron class by providing a predefined 
* activation function that is used to ensure the neuron model output adheres 
* to boolean values of 0 or 1.
*/

class BooleanNeuron extends Neuron {
  /*
  * @constructor
  * @param {Number[]} inputWeights An array of initial input weights.
  * @param {Number} bias An initial bias value.
  * @param {function} [activation=BooleanNeuron.activation] The activation function 
  *     can be overridden when creating a training neuron that requires a non-sigmoid
  *     output for error calculations.
  */
  constructor (inputWeights, bias, activation) {
    super (inputWeights, bias, activation || BooleanNeuron.activation);
  }

  /*
  * The activation function uses round() to produce boolean values from the sigmoid.
  * @param {Number} x The sumation of the bias, input and weight calculations.
  */
  static activation (x) {
    return Math.round(BooleanNeuron.sigmoid(x));
  }
  
  /*
  * A sigmoid function is used to squash x value into the range of 0 to 1 where x = 0 returns 0.5.
  * @param {Number} x The value to be squashed into the range from 0 to 1.
  */
  static sigmoid (x) {
    return 1 / (1 + Math.exp(-1 * x));
  }

  // export the model definition values
  getModel () {
    return {
      bias: this.bias,
      weights: this.weights
    };
  }
}




class BooleanTraining {

  /*
  * train neuron using data set
  * @param {Object} neuron The neuron object to train.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  * @param {Number} rate The learn rate used to adjust the weight on an input.
  * @param {Number} tweak Adjustment applied to the error.
  * @param {Number} runs The maximum number of training runs to attempt.
  * @param {Number} target The target error value for the model.
  */
  static train (neuron, dataSet, rate, tweak, runs, target) {
    let error;
    let count = 0;
    while (++count < runs) {
      // get current model error
      error = BooleanTraining.calculateError(neuron, dataSet);
      if (isNaN(error)) throw new Error(`Error is NaN!`);
      // check if error target has been achieved
      if (error < target) break;
      // train each input weight
      BooleanTraining.adjustWeightsBias(neuron, dataSet, rate, tweak, error);
      // validate error reduced
      let adjustError = BooleanTraining.calculateError(neuron, dataSet);
      if (adjustError > error) console.log(`Adjustment failed! ${adjustError} > ${error}`)
      error = adjustError;
    }
    return { error, count };
  }


  /*
  * train neuron using data set
  * @param {Object} network The neuron network object to train.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  * @param {Number} rate The learn rate used to adjust the weight on an input.
  * @param {Number} tweak Adjustment applied to the error.
  * @param {Number} runs The maximum number of training runs to attempt.
  * @param {Number} target The target error value for the model.
  */
  static trainNetwork (network, dataSet, rate, tweak, runs, target) {
    let error;
    let count = 0;
    while (++count < runs) {
      // get current model error
      error = BooleanTraining.calculateError(network, dataSet);
      if (isNaN(error)) throw new Error(`Error is NaN!`);
      // check if error target has been achieved
      if (error < target) break;
      // train each network layer
      networkLoop:
      for (const layer of network.layers) {
        for (const neuron of layer.neurons) {

          // get current model error
          error = BooleanTraining.calculateError(network, dataSet);
          if (isNaN(error)) throw new Error(`Error is NaN!`);
          // check if error target has been achieved
          if (error < target) break networkLoop;
          // train each input weight
          BooleanTraining.adjustWeightsBias(neuron, dataSet, rate, tweak, error, network);
        }
      }

      // validate error reduced
      let adjustError = BooleanTraining.calculateError(network, dataSet);
      if (adjustError > error) console.log(`Adjustment failed! ${adjustError} > ${error}`)
      error = adjustError;
    }
    return { error, count };
  }

  /*
  * adjust neuron weights and bias to reduce the error
  * @param {Object} neuron The neuron object to adjust.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  * @param {Number} rate The learn rate used to adjust the weight on an input.
  * @param {Number} tweak Adjustment applied to the error.
  * @param {Number} error The current error value for the neuron/network.
  * @param {Object} network (optional) The network object if adjusting a neuron inside a network.
  */
  static adjustWeightsBias (neuron, dataSet, rate, tweak, error, network) {
    let trainWeights = neuron.weights.slice();
    neuron.weights.forEach((weight, i) => {
      let weightRecall = weight;
      neuron.weights[i] += tweak;
      // calculate neuron error
      let weightError = BooleanTraining.calculateError(network || neuron, dataSet);
      trainWeights[i] = weightRecall - rate * ((weightError - error) / tweak);
      neuron.weights[i] = weightRecall;
    });
    // train neuron bias
    let trainBias = neuron.bias;
    let biasRecall = neuron.bias;
    neuron.bias += tweak;
    // calculate neuron error
    let biasError = BooleanTraining.calculateError(network || neuron, dataSet);
    trainBias = biasRecall - rate * ((biasError - error) / tweak);
    neuron.bias = biasRecall;

    // apply training results
    neuron.weights = trainWeights.slice();
    neuron.bias = trainBias;
  }


  /*
  * quantify the error in the neuron model compared to training data set
  * @param {Object} neuron The neuron object to train.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  */
  static calculateError (neuron, dataSet) {
    let error_val = 0;
    for (const row of dataSet) {
      let y = neuron.model(row.inputs);
      error_val += Math.pow(y - row.result, 2);
    }
    return error_val / dataSet.length;
  }

  /*
  * test a neuron against a data set
  * @param {Object} neuron The neuron object to train.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  */
  static test (neuron, dataSet) {
    let success = true;
    for (const row of dataSet) if (neuron.model(row.inputs) !== row.result) success = false;
    return success;
  }

  /*
  * show neuron output from data set
  * @param {Object} neuron The neuron object to train.
  * @param {Object[]} dataSet An array of objects with the neuron input values and expected output result.
  */
  static showOutput (neuron, dataSet) {
    for (const data of dataSet) {
      let output = neuron.model(data.inputs);
      console.log(`In: [ ${data.inputs.join(" | ")} ] Out: ${output},  expected ${data.result} ${data.result === output ? "SUCCESS" : "FAILURE"}`);
    }
  }

  /*
  * show the boolean model values
  * @param {Object} neuron The neuron object to train.
  */
  static showModel (neuron) {
    let model = neuron.getModel();
    console.log("Neuron Model:");
    console.log(`  bias: ${model.bias}`);
    console.log("  weights:");
    neuron.weights.map((weight, i) => console.log(`    input ${i}: ${weight}`));
  }

  /*
  * show the boolean model for a network of neurons
  * @param {Object} network The NeuronNetwork object.
  */
  static showNetworkModel (network) {
    console.log("Network model:");
    network.layers.forEach((layer, i) => {
      console.log(`  Layer ${i + 1}`);
      layer.neurons.forEach((neuron, i) => {
        console.log(`    Neuron ${i + 1}`);
        BooleanTraining.showModel(neuron);
      });
    });
  }
}

</script>
</body>
</html>
